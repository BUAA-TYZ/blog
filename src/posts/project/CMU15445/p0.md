---
date: 2024-07-11
category:
  - 数据库
tag:
  - C++
footer: 凉了的馒头
---

# CMU15445 (Spring 2023) Project #0 - C++ Primer


## 前言  

写这篇文章，初衷是因为网上很少有CMU15445-2023的博客文章。记录下我在做的过程中走过的弯路，一方面是对自己工作的一个总结，另一方面也能帮助到在做这门课的 #project 时踩坑而无从下手的同学，何乐而不为？

  


**2023-06-25** 补充 task2 内容

**2023-07-21** 补充 task3 内容

**2023-08-23** 补充截断的原因

**2023-10-27** 补充环境配置


## 一、你需要提前知道的  

> 我使用的编译环境： 系统：Ubuntu 20.04.1 IDE：Clion  
> 推荐使用 Ubuntu 22.04 版本

### 环境配置  

环境配置其实需要对 Linux 有一定的了解，然而有一定的了解的人一般都已经配好了环境。所以环境配置的适用者主要针对新手。然而新手的知识欠缺的知识太多， 确实很难面面俱到。下面是我个人在写这个项目时的配置：

1. 如果没有 Linux 环境，先装个 Vmware

[Vmware安装](http://t.csdnimg.cn/btQ6e)

2. 安装 Linux 镜像，一定选择 Ubuntu22.04 版本 (安装的网络一定选择NAT模式)

[安装镜像](http://t.csdnimg.cn/49pUQ)

截止**2024-06-08**，似乎上面两个链接都已失效。直接上CSDN搜索安装教程即可，CSDN虽然在很多方面为人诟病，但安装教程相对还是比较可靠的。

并且即使不做这个项目，安装一个linux虚拟机玩也是有利无害的。

3. 给虚拟机配置代理。如果没有 VPN，几乎以后所有安装配置都不可能成功(除非你在国外)。**自行寻找**VPN

![](/assets/posts/CMU15445-Refs/p0/1.png)  

打开允许局域网接入

随后 win+R, 输入 cmd，输入ipconfig

![](/assets/posts/CMU15445-Refs/p0/2.png)  

记住这个 IP 地址。在虚拟机中打开设置，随后配置代理

![](/assets/posts/CMU15445-Refs/p0/3.png)  

随后打开终端，export -p 检查一下，应该能找到如下两行

```
http_proxy=http://10.194.96.135:7890/
https_proxy=http://10.194.96.135:7890/
```

说明配置完成，随后 `ping www.github.com` 试一下

**到这里虚拟机网络就配置好了**

4. 安装git准备拉入官方代码

`sudo apt update` 

`sudo apt upgrade`

`sudo apt install git` 

如果上面的任一步完成不了，上网搜索，换一个 22.04 的清华源，再安装。

随后配置 git 代理

```
git config --global http.proxy 'http://192.168.0.1:1080' #填你们自己的代理，这里就是个例子
git config --global https.proxy 'http://192.168.0.1:1080'
```

5. 找一个文件夹，然后按照官方库描述的 git 操作，一步不差的执行

这之后就已经成功了，再挑选一款顺手的 IDE 即可

- 在 Linux 下推荐使用 Clion，对于激活码什么的自己想办法解决。
- 也可以 Vscode ssh 进虚拟机，在 Windows 下写代码。这又是另一个话题了。

当然现在 WSL 也有很多人推荐使用。然而就我个人认为，虚拟机除了性能会有一定的损失，别的都比 WSL 方便多了。

- 使用虚拟机的快照功能，你完全不用担心软件安装的失败等等问题，直接重头再来。我个人曾经安装一个东西时，安装的各个插件版本不匹配。而官方又没有提供删除脚本，最后导致整个安装都失败了，删除也删不干净。幸亏，我在安装前对虚拟机做了一次快照，安装失败后直接重新回到快照节点就好了。
- 使用虚拟机的暂停功能，保存你的所有工作状态，一键还原工作场景
- 虚拟机可以安装许多台，非常灵活，你甚至可以用它们搭建一个 k8s
- 非常稳定，不会像 WSL 偶尔出现难以解决的问题


### 语法要求  

* 掌握 基本C++11语法（C++Primer）
* 简单的 C++17语法，如：string\_view

### 重点掌握  

* dynamic\_cast基本用法
* 智能指针的基本用法

### 资料推荐  

* C++ Primer 第五版
* Effective Modern C++

前者几乎囊括了 C++11 的所有，后者可以更详细地了解右值、万能转发等概念。

***如果你想速成这个 lab，就省略资料推荐，找个网课看或许速度更快。***


## 二、四个Task  

### Task #1 - Copy-On-Write Trie  

`2023年的 #project0 实现与往年不同，实现的是一棵可持久化的字典树。` 具体什么是可持久化的字典树，不建议上网搜索，网上的版本普遍和这个项目的版本有实现上的区别。

其实[官方描述](https://15445.courses.cs.cmu.edu/spring2023/project0/)中写的较为清晰，建议反复阅读直到真正看懂再开始实践做题。

这一部分，我们要完成 Get、Put、Remove操作

建议先从 Get 入手。 `std::string_view 就是一个字符串视图，它支持size、begin、end、下标操作` 我们可以将其当作一个只读字符串。

### Get( ) 思路  

我们沿着字符串找到最后的节点。然后使用`dynamic_cast`转换。`dynamic_cast`允许指针安全地向下转换（即由基类转为派生类指针），失败则返回 nullptr 。但这里的问题是智能指针不支持这个转换，故我们使用智能指针的 get( ) 方法取得裸指针，然后再进行转换就好了。

接着写 Put

### Put( ) 思路  

这里的关键在于阅读好官方对该方法的说明。我们在插入节点时，并非是在原Trie上插入节点，而是在搜索要插入节点的路径上不断 Clone( )，只有这样，我们才能得到非const的节点来对其children\_进行操作。我的做法是使用多个指针进行维护，初始时两个指针都指向父节点，然后令一个指针下探进行操作，另一个指针不变，等操作完后更新父节点，再下探。

课程不给展示代码，我附一点点帮助大家理解并开头

```cpp
std::shared_prt<TrieNode>cur = std::shared_ptr<TrieNode>(root_->Clone());
```

其次要意识到 Clone( ) 是得到一个全新的节点，我们需要记得与它的上一层节点保持连接。

最后附一个想了很久的bug，我在网上找了很久没一个人提到...可能大家都默认了...

```cpp
//B是A的派生类
//b是B类型的对象
std::shared_ptr<A> a = std::make_shared<A>(b);

```

看这个例子，我想当然的认为`make_shared`会保留多态性质生成一个指向b的基类指针。然而事实是`make_shared`会先截断b，只留下A部分的值，然后生成指针。在本题中就是**TrieNodeWithValue**会被截断为**TrieNode**，那就错了。

这样的bug非常难找，找到之后也很难绕过来，网上也找不到相关说明，非常折磨。

正确做法是

`std::shared_ptr<A> a = std::make_shared<B>(b);`

如下：最后分别打印 A B

```cpp
#include <iostream>
#include <memory>

using namespace std;
class A{
public:
    virtual void print() {
        cout << "A" << endl;
        }
    };

class B: public A {
public:
    void print() override {
        cout << "B" << endl;
        }
    };

int main() {
    B b{};
    shared_ptr<A> ptr1 = make_shared<A>(b);
    shared_ptr<A> ptr2 = make_shared<B>(b);
    ptr1->print();
    ptr2->print();
    //shared_ptr<A>ptr3 = shared_ptr<A>(ptr2);
    //ptr3->print();
}

```

**那么，为什么 `shared_ptr<A> ptr1 = make_shared<A>(b)` 会截断呢？**

我们可以看一下 `make_shared` 是怎么写的。

```cpp
template<typename T, typename... Args>
shared_ptr<T> make_shared(Args&&... args) {
    return shared_ptr<T>(new T (std::forward<Args>(args)...));
} 

```

不难发现它是调用 new 全新构造了一个 `shared_ptr<T>` ，new 的参数就是我们传递给它的参数，这里是值语义的调用。它实际调用了 `new A(b)`。 这里数据被截断了。 而对于 `shared_ptr<A> ptr2 = make_shared<B>(b)` ，它实际调用 `new B(b)` 这里数据不会被截断，后续只是指针类型被声明为了 A。

**而为什么 `shared_ptr<A>ptr3 = shared_ptr<A>(ptr2)` 这句不会截断呢？**

因为 shared\_ptr 的拷贝构造函数只需要复制指针就好了。所以这里 ptr3 指向的和 ptr2 指向的是一个地方，是指针语义。而指针/引用 可以多态，所以这里不会截断。

---

最后写Remove

### Remove( ) 思路  

Remove的过程要意识到不只要删除规定节点。 原因： 如果规定节点的父节点只有这一子节点并且自己不是一个值节点，那么我们也需要顺带把它清理掉。这一过程是递归的，我们要从底往上一个一个清理直到遇到不能清理的。

### Remove( ) 实现  

这里我的做法是开一个 vector 记录路径节点避免递归，然后从最后向前迭代，按上面的做法删除节点。 顺便一提，`const_cast`可以消除指针的const属性，可能有时候要用到。但如果你要大量使用之，无疑是你的设计出现了问题。这道题完全可以不用`const_cast`完成。

### Task #2 - Concurrent Key-Value Store  

这一部分我们要完成并发条件下的读写。 这里不要想复杂了，关键在于好好体会可持久化字典树的优势，**好好阅读官方文档**。

### 思路  

我们在这里完全不用读写锁，只需要两把互斥锁，但得益于可持久化字典树每一次 Put、Remove 都会生成一个新版本的字典树，我们天然地解决了读写者的问题。因为每一个线程的 Put、Remove 都是对新树操作，完全不会影响到别的线程上的 Get，Get 仍在读旧版本的字典树。 (这段可能编完就懂了)

---

2023.06.25

  


下面大致介绍一下结构

![](/assets/posts/CMU15445-Refs/p0/4.png)  

`trie_store.h`

  


这个`TrieStore` 类就是对 `Trie` 的一个包装，含有两把锁，`root_lock_` 用于 Get ，`write_lock_` 用于 Put 和 Remove

其中 Get 方法前四行如此：

```cpp
{
    std::lock_guard guard(root_lock_);
    auto cur = root_;
}
```

我们考虑多个线程同时读的情况，因为读并不会修改 `Trie` 所以我们并不需要对整个 Get 上锁

而相比之下，Write 要整个函数上锁，因为我们不能允许多个线程同时写。而这里我们用另一把锁而不用`root_lock_`，是因为 Put 返回的是一棵新的`Trie`, 在此期间就算 Get ，其读到的也是旧的 `Trie` 上的内容。我们不在乎

按这个逻辑思考下来不难发现一个问题，Get 时似乎没有必要上读锁，既然 Get 不会改变 `Trie` 而 Put Remove 又用的另一把锁，那有什么上锁的必要呢。关于这个问题，我这里的思考是：为了保持时效性。我们考虑下面三个线程，它们按时间顺序由`用户`执行，注意不是线程执行的顺序，而是用户下达命令的时间顺序：

用户依次下达命令1，2，3

命令1：Get

命令2：Write

命令3：Get

但线程执行顺序并不会按照我们预想的那样。如果没有读锁，我们完全可以假设命令3最先完成，随后是命令2，最后是命令1。这样我们后下达的命令反而得到了旧的结果，先下达的命令得到了新的结果。结合下面浏览器搜索历史的例子，这就意味着可能出现一开始是新的搜索历史，而一段时间后反而是旧的搜索历史这样的反直觉行为。  

而如果有一把读锁，则我们可以肯定命令3不会早于命令1，因为命令3拿到的 `root_`一定比命令1的更新。


### 实现  

Get 在获取 `root_` 时上锁

Put、Remove 对整个函数上锁

  


如果是C++11之后，请使用`std::lock_guard`管理你的`std::mutex`

C++17之后可以使用`std::scoped_lock`管理

[我的笔记](http://t.csdn.cn/OQNc9)

---

  


2023.06.25

顺便解释一下 `std::optional` ，最近学了些Rust 对它的理解比较深，`std::optional`就等价于 rust 中的 `Option` 。其要么为空，要么为一个值。譬如我们考虑设计一个空队列，我们对其进行`pop`，那队列为空，我们可以考虑抛出一个异常来提醒用户。也可以用`std::optional`，因为是空队列，我们就返回`std::nullopt` ，表示 `None`，这个队列啥都没有。如果队列非空，我们就返回一个值。上面两种情况不论返回值是空，还是一个值，我们都统一用一个返回值`std::optional`表示，更加的安全、简洁。用户当收到一个`std::optional`时也起到提醒用户的作用。

---


写完前两个 Task，便理解可持久化的含义了。它保存了不同版本的字典树，而并非始终对同一棵字典树进行修改。

举个例子：字典树的一个使用场景就是平常我们使用搜索网站的搜索历史。我们每搜索一次就相当于创建一个新的叶结点。如下图：小明想学习C语言和C++，于是小明打开百度搜索这两个关键词，于是搜索历史形成了一个小字典树。其中圆形代表中间节点，正方形代表叶结点。

![](/assets/posts/CMU15445-Refs/p0/5.png)  

小明利用百度偷偷卷,经过努力，小明在一周内速成了C语言，他决定将这个搜索记录删了，因为他认为自己已经掌握了C。于是字典树变成了不好看的链表状。

时间过得很快，一年后，小明发现自己已经把 C 忘光了，以至于他忘记自己学的语言是啥名字了，他想搜索可是不知道名字。更糟糕的是，这时他已经把字典树修改了，回不到过去的历史了，看来小明这辈子都学不会 C 语言了。于是，他在心中暗暗发誓：*如果上天能给我再来一次的机会*，*我会对C语言说三个字：... ...*

但是，如果使用**可持久化字典树**，小明只需回调到上个版本即可，因为其可以保存每一次搜索的字典树！于是小明又可以愉快地继续学习了。他很感激可持久化字典树又给了他再来一次的机会。

### Task #3 - Debugging  

Clion 是很强大的 IDE，一开始入手肯定都会不适应，慢慢来就好了，可以进入设置选择 plugin ，然后输入 chinese 下载对应的简体中文插件。

在 Clion 下，在配置里，课程已经写好了编译文件，我们在 clion 右上角的编译里找到对应的 `debug_test`并调试即可。clion 的调试对于这种小型结构威力很强，很方便。最终 这里我 debug 出来是 8、1、42 答案是对的，但问题是这个结果依赖于随机数，评测系统生成出来的不是这三个数。 解决方法在这个大佬的文章里：[https://zhuanlan.zhihu.com/p/613920859](https://zhuanlan.zhihu.com/p/613920859)

![](/assets/posts/CMU15445-Refs/p0/6.png)  

像这样

  

![](/assets/posts/CMU15445-Refs/p0/7.png)  

最后答案 7、2、30

  


### Task #4 - SQL String Functions  

比较简单，转换大小写可以使用STL算法 `std::transform`。另外需要注意的就是返回异常类型时，不要使用`std::exception()` 项目里有自己的`Exception()` 按要求构造就完事了。


## 三、评测注意  

1. 评测网站，官网上的FAQ中有写
2. **只有格式对了，才会开始打分，否则一律0分！**

### 补充：  

我后来给电脑加装了块国产的 2t 硬盘，于是又搞了台新的虚拟机 装了 ubuntu 22.04 版本。安装 clang-format 等都没问题。所以推荐在 22.04 版本下写项目

  


## 四、总结  

期中考试期间断断续续写完这个 project 感觉收获不少，尤其是智能指针，总的来说体验还是不错滴！

附上评测

![](/assets/posts/CMU15445-Refs/p0/8.png)  



![](/assets/posts/CMU15445-Refs/p0/9.png)  

