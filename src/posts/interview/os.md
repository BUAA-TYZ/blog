---
date: 2025-03-01
category:
  - 面经
tag:
  - 操作系统
footer: 凉了的馒头
---

# 操作系统

结合 `MIT6.S081`

## 进程同步方式

> 同步方式：多个进程或线程在访问共享资源或执行协作任务时，按照一定的时序关系进行协调，以确保数据一致性和操作的正确性。
> 进程同步，指的就是进程通信的方式

1. 管道，半双工，无名管道用于父子进程通信，有名管道以文件形式存在，任意进程通信。本质上利用了内核的缓冲区。
2. 共享内存
3. 信号量，分为 P 和 V 操作，P - 1，V + 1
4. 消息队列
5. socket

## 线程同步方式

1. 互斥锁
2. 读写锁
3. 条件变量
4. 信号量

## 用户态内核态切换过程

1. 触发事件
   - 系统调用
   - 硬件中断
   - 异常（e.g. 缺页）
2. 保存用户态上下文
   - CPU 保存寄存器
   - 切换堆栈，从用户栈切换到内核栈
3. 切换到内核态
   - 更新 CPU 权限
4. 执行内核处理程序
   - 根据中断向量号查找**中断描述符表**，定位处理函数
5. 返回用户态，恢复上下文
6. 一次切换的时间大概是 百ns 级别的
7. 不涉及页表切换（xv6涉及）

## 协程与线程上下文切换过程

libco 下关于协程上下文的结构体，可以看到协程上下文非常轻量
```c
struct coctx_t
{
	void *regs[ 14 ];       // 一个数组，保存了14个寄存器的值 
	size_t ss_size;         // 协程栈大小
	char *ss_sp;            // 协程栈指针
};
```

1. 协程切换直接更换寄存器即可
2. 一次切换大概 十ns 级别的，全部在**用户态**运行

相比之下线程的切换更加复杂，且涉及用户态和内核态的切换：

1. 保存 CPU 状态
2. 触发 syscall 进入内核（e.g. `sched_yield()`）
3. 内核调度器进行调度选择下一个内核
4. 切换到另一个线程的地址空间（可能会切换地址空间，导致 TLB 刷新）
5. 恢复线程B的 CPU 状态
6. 返回用户态
7. 一次切换大约是 **微秒** 级别的

可以看出多线程可以充分利用多核，而协程全部运行在一个线程里，所以实际上并不是并行的，更加适合 IO 密集型任务，即瓶颈不在 CPU 的任务中。

## Why 虚拟内存

1. 隔离，不同的进程不能互相访问彼此的内存空间
2. 易于管理，操作系统不用复杂的安排物理内存
3. 懒分配，可以申请超过物理内存的虚拟内存