import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,d as a,o as t}from"./app-Cc-V_zzY.js";const n="/blog/assets/posts/CMU15445-Refs/p2-1/1.png",l="/blog/assets/posts/CMU15445-Refs/p2-1/2.png",p="/blog/assets/posts/CMU15445-Refs/p2-1/3.png",r="/blog/assets/posts/CMU15445-Refs/p2-1/4.png",h={};function o(d,i){return t(),s("div",null,i[0]||(i[0]=[a(`<h1 id="cmu15445-spring-2023-project-2-b-tree-checkpoint-1" tabindex="-1"><a class="header-anchor" href="#cmu15445-spring-2023-project-2-b-tree-checkpoint-1"><span>CMU15445 (Spring 2023) Project #2 - B+Tree Checkpoint #1</span></a></h1><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言"><span>前言</span></a></h2><p>因为之前忙着期末考试和实习相关事宜，有一阵子没学习这门课程了，最近将它重新捡起来。</p><p>这次的项目比较仁慈，总体分为 2 个 Checkpoint，允许我们阶段性地检验成果，Checkpoint1# 负责页结构的补全和 B+ 树插入逻辑的实现， CheckPoint2# 负责 B+树的删除逻辑，迭代器实现以及并发。</p><p>本文主要聚焦于 Checkpoint1 的想法与实现。</p><h2 id="你可能需要知道的" tabindex="-1"><a class="header-anchor" href="#你可能需要知道的"><span>你可能需要知道的</span></a></h2><ul><li><a href="https://15445.courses.cs.cmu.edu/spring2023/project2/" target="_blank" rel="noopener noreferrer">官方文档</a></li><li><strong>Textbook上的伪代码</strong></li></ul><p>建议先自己写试试，写不出来再参考伪代码，毕竟这也是一次锻炼的机会</p><h2 id="task-1-b-tree-pages" tabindex="-1"><a class="header-anchor" href="#task-1-b-tree-pages"><span>Task #1 - B+Tree Pages</span></a></h2><h3 id="理解" tabindex="-1"><a class="header-anchor" href="#理解"><span>理解</span></a></h3><p>总共需要补全三种页类型，</p><ul><li><strong><a href="https://15445.courses.cs.cmu.edu/spring2023/project2/#b+tree-page" target="_blank" rel="noopener noreferrer">B+Tree Page</a></strong></li><li><strong><a href="https://15445.courses.cs.cmu.edu/spring2023/project2/#b+tree-internal-page" target="_blank" rel="noopener noreferrer">B+Tree Internal page</a></strong></li><li><strong><a href="https://15445.courses.cs.cmu.edu/spring2023/project2/#b+tree-leaf-page" target="_blank" rel="noopener noreferrer">B+Tree Leaf page</a></strong></li></ul><p>其中后两者继承于 <code>B+Tree Page</code> ，属于 Is A 的关系。这也是一个比较常见的做法，将基本的公共信息提取放到基类中，发挥复用的优势。</p><p>对于 <code>B+Tree Internal Page</code>和 <code>B+Tree Leaf Page</code> ，它们都有一个 奇怪的成员 <code>MappingType array_[0]</code> 并不是说这真的是一个大小为 0 的数组，它是一个可变长的数组，作为类的最后一个数据成员，最终会根据这个类的大小来动态为 array_ 分配空间。在编程时，用 <code>GetSize()</code> 方法获取 array_ 长度，<code>GetMaxSize()</code>方法获取 array_ 最大长度。</p><p>对于<code>B+Tree Internal Page</code>，它的 Value 类型 是 page_id_t 即它指向下一个页面</p><p>对于<code>B+Tree Leaf Page</code>，它的 Value 类型不用关注。</p><h3 id="实现" tabindex="-1"><a class="header-anchor" href="#实现"><span>实现</span></a></h3><p>实现总体来说没有什么坑，都非常简单。除了一点，对于 <code>B+Tree Internal Page</code> 的 <code>KeyAt()</code> 方法，简介中说 index 不能为 0 。这个我觉得可以不用管，因为后面调配 Key 的时候不可避免的要用到 index 为 0 时候的 Key。但要有 index=0 这个位置要小心的意识。</p><h2 id="task-2a-b-tree-insertion-and-search-for-single-values" tabindex="-1"><a class="header-anchor" href="#task-2a-b-tree-insertion-and-search-for-single-values"><span>Task #2a - B+Tree Insertion and Search for Single Values</span></a></h2><h3 id="理解-1" tabindex="-1"><a class="header-anchor" href="#理解-1"><span>理解</span></a></h3><p>这部分的逻辑课上书上有讲，复现即可。<strong>其中有许多琐碎的细节，不太好阐述，需要靠自己摸索</strong>。且这些细节大部分不好和实现分开讲解，所以我都放到了下一部分。</p><h3 id="实现-1" tabindex="-1"><a class="header-anchor" href="#实现-1"><span>实现</span></a></h3><p>在开始之前，<strong>务必</strong>尝试一下课程官方提供的 <a href="https://15445.courses.cs.cmu.edu/spring2023/bpt-printer/" target="_blank" rel="noopener noreferrer">Reference Solution</a></p><p>主要观察 Internal Page 和 Leaf Page 在 <code>max_size</code> 上的不同，</p><ul><li>对于 Leaf Page 其储存的节点数最大永远是 <code>leaf_max_size - 1</code>，永远存不满</li><li>对于 Internal Page 其储存的节点数最大正好是 <code>internal_max_size</code>，可能被存满</li></ul><p>这样的不同造就了节点满时，插入逻辑的不同。因为节点满，再要插入，我们就必须分裂当前节点。对于 leaf page ，分裂时因为大小有空余不会被存满，所以我们直接先插入再分裂；而对于 Internal page，如果先插入，可能导致空间溢出，所以我们可以考虑以下两种插入方法</p><ul><li>Textbook 中的方法，创建一片空间容纳页的内容，在这片空间上插入，随后分配到分裂的两页当中，要进行 2 次复制</li><li>先将页分裂，然后选择要插入的页进行插入，要进行 1 次复制</li></ul><p>我采取了第二种方法，不过这个方法很容易产生 bug ，关键就是 产生的新页上的 index=0 的位置，这个位置是插入不到的（因为 Internal page 0 处的索引不参与搜索），所以万一要插入的正好是那个位置，就无能为力了。解决方法是分类讨论，细心处理 index 的边界情况。</p><p>对于如何取得页进行操作，参考 <code>b_plus_tree.cpp</code> 的第 20 行到第 22 行，先根据 <code>page_id</code> 取得 guard ，随后强制转换成对应的类型进行操作。（ 插一嘴，这里的 AsMut 和 As 体现了写这个的人很喜欢 Rust 。）使用 guard 是必须的，强大的 RAII 方法自动帮助我们管理页，我们不需要像 2022 那个版本那样手动 Unpinpage 了，大大减少了心智负担。</p><p>这里的强制转换用到了 C++ 的 <code>reinterpret_cast</code> ， 因为类型归根到底就是一堆二进制，关键看你如何解释它。比如, 你可以把 127 看成整数，也可以看成 char 类型。<code>reinterpret_cast</code> 就是改变看二进制方式的工具。 <strong>注意 BPlusTree 的开头</strong>，那儿定义了两个 using 别名方便我们 <code>reinterpret_cast</code> 的时候使用</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> InternalPage</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BPlusTreeInternalPage</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">KeyType</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">page_id_t</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">KeyComparator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> LeafPage</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BPlusTreeLeafPage</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">KeyType</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ValueType</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">KeyComparator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><em><strong>帮助函数</strong></em></p><p>另外，推荐在 <code>b_plus_tree.cpp</code> 实现一个函数<code>GetLeafPage()</code> ，功能是根据 Key 找到最终的 leaf page 的 id 。</p><p>在这个方法实现的过程中，你会发现需要对页的内容进行搜索，考虑到页是有序的，我们使用<strong>二分搜索</strong>，你可以使用 C++ 自带的库函数，不过我不太会用；也可以像我一样手动实现。</p><p>写二分之前可以先做一下这道题 ：</p><p><a href="https://leetcode.cn/problems/search-insert-position/" target="_blank" rel="noopener noreferrer">简单的二分</a></p><p>下面是我的函数签名，在<code>b_plus_tree_internal_page.cpp</code> 中实现</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/**</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * </span><span style="--shiki-light:#A626A4;--shiki-light-font-style:italic;--shiki-dark:#C678DD;--shiki-dark-font-style:italic;">@return</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> Index i which KeyAt(i) &lt;= key &lt; KetAt(i + 1)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> GetKeyIndex</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> KeyType</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">KeyComparator</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> comparator_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> -&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">；</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于我们不知道如何比较大小，还需要传入比较符，像这样比较大小：<code>(comparator_(page_key, key) == 0)</code></p><p>有了这个 <code>GetLeafPage()</code>方法后，<code>GetValue()</code> 就非常好写了。</p><p>下面是重头戏 <code>Insert()</code> ， 这部分的逻辑确实不太好想，如果实在想不出来，就参考伪代码吧！伪代码有一部分是用递归写的，我们可以用迭代模拟出来。</p><p>总体的思路就是，先判断树是否为空，为空则创建树。不为空则往下走并把路径节点加入到 <code>ctx.write_set_</code> 中，最后走到需要插入的叶节点，如果非满则直接插入，满了则分裂，并将新叶节点的第一个 Key 上推到父节点（<code>ctx.write_set_.back()</code>） 如果父节点也是满的就继续向上分裂，以此类推...</p><p>也别忘了将一些方法归纳为成员函数加入到 <code>b_plus_tree_internal_page.h</code> 和 <code>b_plus_tree_leaf_page.h</code>中去</p><p>如页的搜索，页的插入，页的分裂 这些都可以归纳到页那个类中，下面是我的 页的插入的函数签名：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">/**</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> * </span><span style="--shiki-light:#A626A4;--shiki-light-font-style:italic;--shiki-dark:#C678DD;--shiki-dark-font-style:italic;">@brief</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> This internal page isn&#39;t full. Insert (key, value) into this page.</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> Insert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> KeyType</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">key</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ValueType</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">KeyComparator</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> comparator_</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>附书本上的伪代码：</p><p><img src="`+n+'" alt="" loading="lazy"><br><img src="'+l+`" alt="" loading="lazy"></p><p><em><strong>并发相关</strong></em></p><p>对于 <code>PageGuard</code>，我的第一次实现为了以后方便就使用了 <code>ReadPageGuard</code> 和 <code>WritePageGuard</code> 并使用了课上讲的并发策略：螃蟹步伐，但实际上这个 Checkpoint1 是单线程的，也可以先都使用 <code>BasicPageGuard</code> ，等后续需要多线程再改。</p><p><em><strong>过程思考</strong></em></p><p>最后写几个过程中的思考：</p><ol><li>对于已存在的 internal page ，我们可能插入到它的最左边吗？</li><li>写的过程中关注了 <code>PageGuard</code> 的生命周期了吗？</li><li>Leaf page 和 Internal page 很多地方的实现都不一样，做出了区分吗？</li><li>页分裂时的细节</li></ol><h3 id="可视化工具" tabindex="-1"><a class="header-anchor" href="#可视化工具"><span>可视化工具</span></a></h3><p>课程提供了可视化工具 <code>b_plus_tree_printer</code>，可以生成 .dot 文件。可惜的是，Clion 上的 .dot 插件不太行，显示不出课程生成的 .dot 文件。我们需要借助一个工具 graphviz</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 安装</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sudo</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> apt</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> install</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> graphviz</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 将 .dot 转为 .png</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">dot</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -Tpng</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> mytree.dot</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> &gt; </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">mytree.png</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样我们就可以在 Clion 中打开 .png 来观看树的样子了。</p><p>附一张自己构造的超大 B+ 树，可以看出即使 <code>max_size</code> 不大，最终也只有五层。</p><figure><img src="`+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="最后" tabindex="-1"><a class="header-anchor" href="#最后"><span>最后</span></a></h2><p>再一次感受到课题组的用心，我们不仅可以免费获得听取课程的机会（想想 CMU 的学费），还能获得评测资源以及那么好的可视化工具。最终画出自己的 B+ 树的那一刻，感到前面的努力都值得了。整个 Checkpoint1# 做下来，花费的时间并没有想的那么多，总结起来还是 考虑周全 并且 <strong>不要急功近利</strong></p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',61)]))}const g=e(h,[["render",o],["__file","p2-1.html.vue"]]),y=JSON.parse('{"path":"/posts/project/CMU15445/p2-1.html","title":"CMU15445 (Spring 2023) Project #2 - B+Tree Checkpoint #1","lang":"zh-CN","frontmatter":{"date":"2024-07-24T00:00:00.000Z","category":["数据库"],"tag":["C++"],"footer":"凉了的馒头","description":"CMU15445 (Spring 2023) Project #2 - B+Tree Checkpoint #1 前言 因为之前忙着期末考试和实习相关事宜，有一阵子没学习这门课程了，最近将它重新捡起来。 这次的项目比较仁慈，总体分为 2 个 Checkpoint，允许我们阶段性地检验成果，Checkpoint1# 负责页结构的补全和 B+ 树插入逻辑的...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/posts/project/CMU15445/p2-1.html"}],["meta",{"property":"og:site_name","content":"博客演示"}],["meta",{"property":"og:title","content":"CMU15445 (Spring 2023) Project #2 - B+Tree Checkpoint #1"}],["meta",{"property":"og:description","content":"CMU15445 (Spring 2023) Project #2 - B+Tree Checkpoint #1 前言 因为之前忙着期末考试和实习相关事宜，有一阵子没学习这门课程了，最近将它重新捡起来。 这次的项目比较仁慈，总体分为 2 个 Checkpoint，允许我们阶段性地检验成果，Checkpoint1# 负责页结构的补全和 B+ 树插入逻辑的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/blog/assets/posts/CMU15445-Refs/p2-1/1.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-10T03:04:45.000Z"}],["meta",{"property":"article:tag","content":"C++"}],["meta",{"property":"article:published_time","content":"2024-07-24T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-10T03:04:45.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CMU15445 (Spring 2023) Project #2 - B+Tree Checkpoint #1\\",\\"image\\":[\\"https://mister-hope.github.io/blog/assets/posts/CMU15445-Refs/p2-1/1.png\\",\\"https://mister-hope.github.io/blog/assets/posts/CMU15445-Refs/p2-1/2.png\\",\\"https://mister-hope.github.io/blog/assets/posts/CMU15445-Refs/p2-1/3.png\\",\\"https://mister-hope.github.io/blog/assets/posts/CMU15445-Refs/p2-1/4.png\\"],\\"datePublished\\":\\"2024-07-24T00:00:00.000Z\\",\\"dateModified\\":\\"2025-01-10T03:04:45.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Tyz\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"你可能需要知道的","slug":"你可能需要知道的","link":"#你可能需要知道的","children":[]},{"level":2,"title":"Task #1 - B+Tree Pages","slug":"task-1-b-tree-pages","link":"#task-1-b-tree-pages","children":[{"level":3,"title":"理解","slug":"理解","link":"#理解","children":[]},{"level":3,"title":"实现","slug":"实现","link":"#实现","children":[]}]},{"level":2,"title":"Task #2a - B+Tree Insertion and Search for Single Values","slug":"task-2a-b-tree-insertion-and-search-for-single-values","link":"#task-2a-b-tree-insertion-and-search-for-single-values","children":[{"level":3,"title":"理解","slug":"理解-1","link":"#理解-1","children":[]},{"level":3,"title":"实现","slug":"实现-1","link":"#实现-1","children":[]},{"level":3,"title":"可视化工具","slug":"可视化工具","link":"#可视化工具","children":[]}]},{"level":2,"title":"最后","slug":"最后","link":"#最后","children":[]}],"git":{"createdTime":1736478285000,"updatedTime":1736478285000,"contributors":[{"name":"BUAA-TYZ","username":"BUAA-TYZ","email":"2506741037@qq.com","commits":1,"url":"https://github.com/BUAA-TYZ"}]},"readingTime":{"minutes":6.91,"words":2074},"filePathRelative":"posts/project/CMU15445/p2-1.md","localizedDate":"2024年7月24日","excerpt":"\\n<h2>前言</h2>\\n<p>因为之前忙着期末考试和实习相关事宜，有一阵子没学习这门课程了，最近将它重新捡起来。</p>\\n<p>这次的项目比较仁慈，总体分为 2 个 Checkpoint，允许我们阶段性地检验成果，Checkpoint1# 负责页结构的补全和 B+ 树插入逻辑的实现， CheckPoint2# 负责 B+树的删除逻辑，迭代器实现以及并发。</p>\\n<p>本文主要聚焦于 Checkpoint1 的想法与实现。</p>\\n<h2>你可能需要知道的</h2>\\n<ul>\\n<li><a href=\\"https://15445.courses.cs.cmu.edu/spring2023/project2/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">官方文档</a></li>\\n<li><strong>Textbook上的伪代码</strong></li>\\n</ul>","autoDesc":true}');export{g as comp,y as data};
